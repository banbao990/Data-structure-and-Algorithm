# 排序算法

## 0. 复杂度分析

+ 时间复杂度
  + 记录的**比较**和**交换**次数
    + **比较**次数
    + **交换**次数
  + 最好/最坏/平均
+ 基于比较排序的时间复杂度下界 : $O(nlogn)$
    + **判定树**
  
+ 空间复杂度
  + 所需**附加**空间的大小

+ 排序是否稳定
  + 相同关键字的记录在排序前后相对次序是否发生改变

## 1. 简单排序

### 1.1 插入排序([$insertion\ sort$](./insertion-sort.cpp))

+ 依次将每个待排序的记录插入到一个有序子文件的合适位置
+ 时间复杂度 : $O(n^2)$
  + 比较次数的优化
    + **二分**查找
+ 空间复杂度 : $O(1)$
+ 稳定

### 1.2 冒泡排序([$bubble\ sort$](./bubble-sort.cpp))

+ 不停地比较相邻的记录, 如果不满足排序要求, 就交换相邻记录, 直到所有的记录都已排好序
+ 时间复杂度 : $O(n^2)$
  + 优化
    + 设置一个标记, 若该次冒泡没有发生交换, 则排序结束
+ 空间复杂度 : $O(1)$
+ 稳定

### 1.3 直接选择排序([$selection\ sort$](./selection-sort.cpp))

+ 每一趟在后面 $n-i$ 个待排记录中选取最小记录和第 $i$ 个记录互换
+ 时间复杂度 : $O(n^2)$
+ 空间复杂度 : $O(1)$
+ 不稳定

## 2. 希尔排序

### 2.1 希尔排序([$shell\ sort$](./shell-sort.cpp))

+ 又称**缩小增量排序**
+ 基于直接选择排序的如下性质
  + 在待排序序列较短情形下效率高
  + 在整体有序的情形下时间代价低
+ 时间复杂度 : 与增量序列相关
+ $Hibbard$ 增量序列
  + $\lbrace 2^k-1,2^{k-1}-1,…,7,3,1\rbrace$
  + 时间复杂度 : $O(n^{\frac32})$
+ 空间复杂度 : $O(1)$
+ 不稳定

## 3. 分治排序

### 3.1 快速排序([$quick\ sort$](./quick-sort.cpp))

+ 时间复杂度 : $O(nlogn)$
+ 空间复杂度 : $O(1)$
+ 不稳定

### 3.2 归并排序([$merge\ sort$](merge-sort.cpp))

+ 二路归并/多路归并

+ 时间复杂度 : $O(nlogn)$
+ 空间复杂度 : $O(n)$
+ 稳定
+ $Sedgewick$ 优化
  + 不稳定

## 4. 堆排序

### 4.1 堆排序([$heap\ sort$](./heap_sort.cpp))

+ 时间复杂度 : $O(nlogn)$
+ 空间复杂度 : $O(1)$
+ 不稳定

## 5. 分配排序($bin\ sort$)

### 5.1 桶排序([$bucket\ sort$](./bucket-sort.cpp))

+ $m$ 个桶

+ 时间复杂度 : $O(n+m)$
+ 空间复杂度 : $O(n+m)$
+ 稳定

### 5.2 基数排序($radix\ sort$)

+ 桶排序 $m$ 很大时的优化
+ 基数 $r$, 排序码位数 $d$
+ 分类
  + 高位优先法($most\ significant\ digit\ first,MSD$)
    + 分, 分, 分, .. , 分, 收
  + 低位优先法($least\ significant\ digit\ first,LSD$)
    + 分, 收; 分, 收; ... ; 分, 收
    + **计算机常用**
+ 实现方法
  + [$基于顺序存储的实现$](./radix-sort.cpp)
  + [$基于静态链的实现$](./radix-sort-link.cpp)
+ 时间复杂度 : $O(d(n+r))\sim O(nlogn)$
+ 空间复杂度 : $O(n+r)$
+ 稳定

### 5.3 索引排序($index\ sort$)

+ 一种排序思想, 不交换记录

+ 又称**地址排序**
+ 分类
  + [$version1$](./addr-sort.cpp)
    + $index$ 数组当前位置应该存放的元素在原有数组中的索引
  + [$version2$](./addr-sort-index.cpp)
    + $index$ 数组中存放的是原有元素在新数组中应该存放的位置